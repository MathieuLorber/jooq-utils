package jooqutils

import java.nio.file.Files
import java.nio.file.Path
import java.sql.Statement
import jooqutils.util.DatasourcePool
import jooqutils.util.StatementExecutor
import mu.KotlinLogging
import org.jooq.Table
import org.jooq.impl.QueryParser

object DatabaseCleaner {

    private val logger = KotlinLogging.logger {}

    fun clean(conf: DatabaseConfiguration, sqlResultFile: Path?) {
        val commandResult = DatabaseInitializer.dump(conf)
        val fullDump =
            commandResult
                .lines
                // replace comments by end of lines
                .map {
                    if (it.startsWith("--")) {
                        "\n"
                    } else {
                        simplifyQuery(it)
                    }
                }
                .joinToString(separator = "\n")
        logger.debug { fullDump }
        val filteredQueries =
            when (conf.driver) {
                DatabaseConfiguration.Driver.psql ->
                    fullDump.split("\n\n")
                        .map { it.trim() }
                        .filter { !it.startsWith("SET statement_timeout") }
                        .filter { !it.startsWith("SELECT pg_catalog.set_config") }
                        .filter { !it.startsWith("CREATE SEQUENCE") }
                        .filter { !it.startsWith("ALTER SEQUENCE") }
                        // TODO or no reference !!
                        .filter { !it.startsWith("CREATE UNIQUE INDEX") }
                        .filter { !it.startsWith("ALTER DEFAULT PRIVILEGES FOR ROLE") }
                        .filter { !it.startsWith("CREATE TEXT SEARCH CONFIGURATION") }
                        .filter { !it.startsWith("ALTER TEXT SEARCH CONFIGURATION") }
                        .filter { "ADD GENERATED BY DEFAULT AS IDENTITY" !in it }
                        .filter { "SET DEFAULT nextval" !in it }
                        .filter { "REVOKE ALL" !in it }
                        .filter { "GRANT SELECT ON SEQUENCE" !in it }
                        .filter { "GRANT ALL ON TABLE" !in it }

                DatabaseConfiguration.Driver.mysql ->
                    fullDump.split("\n\n")
                        .map { it.trim() }.filter { "SET DEFAULT nextval" !in it }

                DatabaseConfiguration.Driver.sqlite ->
                    fullDump
                        .replace("PRAGMA foreign_keys=OFF;", "")
                        .replace("BEGIN TRANSACTION;", "")
                        .replace("COMMIT;", "")
                        .split(";")
            }
                .filter { it.trim() != "" }
                .map { SqlQueryString(null, it) }
        if (logger.isDebugEnabled) {
            logger.debug { "Filtered queries :" }
            filteredQueries.forEach { logger.debug { it } }
        }

        // TODO index vs constraint
        val classified = QueryParser.classifyQueries(filteredQueries, conf)
        val sb = if (sqlResultFile != null) StringBuilder() else null
        DatasourcePool.get(conf).connection.createStatement().use { statement ->
            val tables = classified.tables.map { it.table.name }.joinToString(separator = ", ")
            logger.debug { "Drop tables $tables" }
            StatementExecutor.execute(statement, "drop table $tables;")
        }
        if (sqlResultFile != null) {
            sqlResultFile.toFile().parentFile.mkdirs()
            Files.write(sqlResultFile, sb.toString().toByteArray(Charsets.UTF_8))
        }
    }

    // TODO because it seems Jooq doesn't like "VARCHAR(255)" for primary keys =s
    fun simplifyQuery(it: String) = it.replace("VARCHAR", "CHARACTER VARYING")
}
