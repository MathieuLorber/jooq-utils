package jooqutils

import jooqutils.util.DatasourcePool
import mu.KotlinLogging
import org.jooq.Table
import org.jooq.impl.DependenciesParser
import org.jooq.impl.QueryParser
import java.nio.file.Files
import java.nio.file.Paths

object DatabaseCleaner {

    private val logger = KotlinLogging.logger {}

    fun clean(conf: DatabaseConfiguration) {
        val commandResult = DatabaseInitializer.dump(conf)
        val fullDump = commandResult.lines
            // replace comments by end of lines
            .map {
                if (it.startsWith("--")) {
                    "\n"
                } else {
                    simplifyQuery(it)
                }
            }
            .joinToString(separator = "\n")
        val queries = fullDump.split("\n\n")
        val filteredQueries = queries
            .map { it.trim() }
            // psql dump
            .filter { !it.startsWith("SET statement_timeout") }
            .filter { !it.startsWith("SELECT pg_catalog.set_config") }
            .filter { !it.startsWith("ALTER SEQUENCE") }
            // TODO or no reference !!
//                .filter { !it.startsWith("CREATE INDEX") }
            .filter { !it.startsWith("CREATE UNIQUE INDEX") }
            .filter { "ADD GENERATED BY DEFAULT AS IDENTITY" !in it }
            // mysql dump
            .filter { !it.startsWith("DROP TABLE") }
            .filter { "SET DEFAULT nextval" !in it }
            .filter { it.trim() != "" }
            .map { SqlQueryString(null, it) }
//        val dependenciesSet = DependenciesParser.getDependenciesSet(filteredQueries, databaseName)
//        val reverseDependenciesSet = getReverseDependencies(dependenciesSet)
        // TODO index vs constraint
        val (index, constraints, tables) = QueryParser.classifyQueries(filteredQueries, conf)
        val sb = StringBuilder()
        DatasourcePool.get(conf).connection.createStatement().use { statement ->
//            dropTables(reverseDependenciesSet, emptySet(), statement, sb)
            index.forEach { index ->
                val sql = "drop index if exists ${index}"
                statement.execute(sql)
                sb.appendLine(sql + ";")
                sb.appendLine()
            }
            constraints.forEach { c ->
                val sql = "alter table ${c.first} drop constraint ${c.second}"
                statement.execute(sql)
                sb.appendLine(sql + ";")
                sb.appendLine()
            }
            tables.forEach { table ->
                val sql = "drop table if exists ${table}"
                statement.execute(sql)
                sb.appendLine(sql + ";")
                sb.appendLine()
            }
        }
        // TODO dir must be a parameter
//        val cleanTablesFile = Paths.get(System.getProperty("user.dir"), "/jooq-lib/build/db/clean-tables.sql")
//        cleanTablesFile.toFile().parentFile.mkdirs()
//        Files.write(cleanTablesFile, sb.toString().toByteArray(Charsets.UTF_8))
    }

    // TODO not useful now but will be
    fun getReverseDependencies(dependenciesSet: Set<DependenciesParser.QueryDependencies>): Map<Table<*>, References> =
        dependenciesSet
            .flatMap { dependencies ->
                dependencies.references.tables.map { it to dependencies.tables }
            }
            .groupBy { it.first }
            .mapValues { References(it.value.flatMap { it.second }.toSet()) }

//    private fun dropTables(reverseDependencies: Map<Table<*>, References>,
//                           alreadyDroped: Set<Table<*>>,
//                           statement: Statement,
//                           sb: StringBuilder) {
//        val dropTables = reverseDependencies
//                .entries
//                .filter { (it.value.tables - alreadyDroped).isEmpty() }
//                .map { it.key }
//                .toSet()
//        dropTables.forEach {
//            logger.debug { "Drop table ${it.name} (if exists)" }
//            val sql = "drop table if exists ${it.name}"
//            statement.execute(sql)
//            sb.appendLine(sql + ";")
//            sb.appendLine()
//        }
//        val remainingRelations = reverseDependencies.filter { it.key !in dropTables }
//        if (remainingRelations.isNotEmpty()) {
//            dropTables(remainingRelations, alreadyDroped + dropTables, statement, sb)
//        }
//    }

    // TODO because it seems Jooq doesn't like "VARCHAR(255)" for primary keys =s
    fun simplifyQuery(it: String) = it.replace("VARCHAR", "CHARACTER VARYING")
}